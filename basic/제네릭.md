# 제네릭을 표현하는 방법들

```typescript
interface GenericIdentityFn {
  <T>(arg: T): T;
}

interface GenericIdentityFnV2<T> {
  (arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

// 함수 선언형태의 표현법
let myIdentity: <T>(arg: T) => T = identity;
// 객체 리터럴 타입의 함수 호출 시그니처로 표현
let myIdentity: { <T>(arg: T): T } = identity;
// 제네릭 인터페이스를 활용한 표현법
let myIdentity: GenericIdentityFn = identity;

let myIdentity: GenericIdentityFnV2<number> = identity;
```

# 클래스 제네릭

```typescript
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function (x, y) {
  return x + y;
};
```

# 제네릭을 활용하는 방법

만약 범용적으로 사용하면서, length 속성을 활용하고 싶을때

```typescript
// 첫번쌔 방법
function loggingIdentityV1<T>(arg: T[]): T[] {
  console.log(arg.length); // 배열은 .length를 가지고 있습니다. 따라서 오류는 없습니다.
  return arg;
}

function loggingIdentityV2<T>(arg: Array<T>): Array<T> {
  console.log(arg.length); // 배열은 .length를 가지고 있습니다. 따라서 오류는 없습니다.
  return arg;
}

// 마지막 가장 확장성이 높은 방법!!
// 인터페이스를 정의해두고
interface Lengthwise {
  length: number;
}

// 해당 인터페이스를 제네릭에 상속한다
function loggingIdentityV3<T extends Lengthwise>(arg: T): T {
  console.log(arg.length); // 이제 .length 프로퍼티가 있는 것을 알기 때문에 더 이상 오류가 발생하지 않습니다.
  return arg;
}

// 아래 코드가 모두 가능해진다.
loggingIdentity([3]);
loggingIdentity(new Array(3));
loggingIdentity({ length: 10, value: 3 });
```

# 함수의 매개변수로 클레스를 제네릭으로 활용하고자 할때

```typescript
function create<T>(c: {new(): T; }): T {
    return new c();
}

```