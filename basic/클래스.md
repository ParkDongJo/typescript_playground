파생된 클래스의 생성자 함수는 기초 클래스의 생성자를 실행할 super()를 호출해야 한다는 점입니다. 더욱이 생성자 내에서 this에 있는 프로퍼티에 접근하기 전에 super()를 먼저 호출해야 합니다. 이 부분은 TypeScript에서 중요한 규칙입니다.

move를 오버라이드해서 각각 클래스의 특성에 맞게 기능을 가진 move를 생성합니다.

# 읽기전용 readonly 키워드

```typescript
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; /
```

```typescript
class Octopus {
  readonly numberOfLegs: number = 8;
  constructor(readonly name: string) {}
}
```

# 생성자 함수

```typescript
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
  greet() {
    return "Hello, " + this.greeting;
  }
}
```

위 코드가 JavaScript 언어로 변환 되었을 시 코드는 아래와 같다

```typescript
let Greeter = (function () {
  function Greeter(message) {
    this.greeting = message;
  }
  Greeter.prototype.greet = function () {
    return "Hello, " + this.greeting;
  };
  return Greeter;
})();

let greeter;
greeter = new Greeter("world");
console.log(greeter.greet());
```

let Greeter 는 즉시 실행함수로 Greeter (function() {}) 그 잡채의 함수 인스턴스를 받았고,
new 키워드를 통해 이 함수를 실행했을 시, Greeter의 인스턴스를 return 받게 된다.

그때부터 Greeter 내부에 있는 greet 를 꺼내어 쓸 수 있게 된다.

typescript는 아래 와 같이 typeof 클래스명을 통해서 클래스 잡채를 type 으로만 사용할 수도 있다.

```typescript
let greeterMaker: typeof Greeter = Greeter;
let greeter2: Greeter = new greeterMaker();
console.log(greeter2.greet()); // "Hey there!"
```

그렇기 때문에, 클래스는 타입 형태로만 사용되는 인터페이스를 사용할 수 있는 동일한 위치에서 사용할 수 있다.

```typescript
class Point {
  x: number;
  y: number;
}

interface Point3d extends Point {
  z: number;
}

let point3d: Point3d = { x: 1, y: 2, z: 3 };
```
